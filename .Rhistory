#Skipping automatic translations for now
other.responses.j <- other.responses #%>% translate.responses
other.responses.j[["response.en"]] <- NA
#Making other requests without translations, other.responses instead of other.responses.j
save.other.requests(create.translate.requests(other.db, other.responses.j, is.loop = F),
make.short.name("other_requests"), use_template = F)
###########  Retailers ########################################################
#To translate additional columns
if (JMMI_variable == "Retailers") {
to_translatex2_1 <- raw.main %>% select(uuid, x2_1_paymet_limitation) %>% mutate(variable = "x2_1_paymet_limitation") %>%
filter(!is.na(x2_1_paymet_limitation))
colnames(to_translatex2_1)[2] <- "old.value"
to_translateu3_7 <- raw.main %>% select(uuid, u3_7_nfi_supplier_another_country) %>% mutate(variable = "u3_7_nfi_supplier_another_country") %>%
filter(!is.na(u3_7_nfi_supplier_another_country))
colnames(to_translateu3_7)[2] <- "old.value"
to_translateu3_4 <- raw.main %>% select(uuid, u3_4_nfi_supply_another_country) %>% mutate(variable = "u3_4_nfi_supply_another_country")%>%
filter(!is.na(u3_4_nfi_supply_another_country))
colnames(to_translateu3_4)[2] <- "old.value"
to_translateu2_7 <- raw.main %>% select(uuid, u2_7_food_supplier_another_country) %>% mutate(variable = "u2_7_food_supplier_another_country")%>%
filter(!is.na(u2_7_food_supplier_another_country))
colnames(to_translateu2_7)[2] <- "old.value"
to_translateu2_4 <- raw.main %>% select(uuid, u2_4_food_supply_another_country) %>% mutate(variable = "u2_4_food_supply_another_country")%>%
filter(!is.na(u2_4_food_supply_another_country))
colnames(to_translateu2_4)[2] <- "old.value"
to_translate <- rbind(to_translatex2_1, to_translateu3_7, to_translateu3_4, to_translateu2_7, to_translateu2_4)
write.xlsx(to_translate, "output/checking/requests/to_translate.xlsx")
rm(to_translatex2_1, to_translateu3_7, to_translateu3_4, to_translateu2_7, to_translateu2_4, to_translate)
}
if (JMMI_variable == "Retailers") {
to_translatex2_1 <- raw.main %>% select(uuid, x2_1_paymet_limitation) %>% mutate(variable = "x2_1_paymet_limitation") %>%
filter(!is.na(x2_1_paymet_limitation))
colnames(to_translatex2_1)[2] <- "old.value"
to_translateu3_7 <- raw.main %>% select(uuid, u3_7_nfi_supplier_another_country) %>% mutate(variable = "u3_7_nfi_supplier_another_country") %>%
filter(!is.na(u3_7_nfi_supplier_another_country))
colnames(to_translateu3_7)[2] <- "old.value"
to_translateu3_4 <- raw.main %>% select(uuid, u3_4_nfi_supply_another_country) %>% mutate(variable = "u3_4_nfi_supply_another_country")%>%
filter(!is.na(u3_4_nfi_supply_another_country))
colnames(to_translateu3_4)[2] <- "old.value"
to_translateu2_7 <- raw.main %>% select(uuid, u2_7_food_supplier_another_country) %>% mutate(variable = "u2_7_food_supplier_another_country")%>%
filter(!is.na(u2_7_food_supplier_another_country))
colnames(to_translateu2_7)[2] <- "old.value"
to_translateu2_4 <- raw.main %>% select(uuid, u2_4_food_supply_another_country) %>% mutate(variable = "u2_4_food_supply_another_country")%>%
filter(!is.na(u2_4_food_supply_another_country))
colnames(to_translateu2_4)[2] <- "old.value"
to_translate <- rbind(to_translatex2_1, to_translateu3_7, to_translateu3_4, to_translateu2_7, to_translateu2_4)
write.xlsx(to_translate, "output/Retailers/checking/requests/to_translate.xlsx")
rm(to_translatex2_1, to_translateu3_7, to_translateu3_4, to_translateu2_7, to_translateu2_4, to_translate)
}
cleaning.log.other <- data.frame()
or.request <- load.requests(dir.requests,  make.short.name("other_requests", no_date = T), sheet = "Sheet2")
or.edited  <- load.requests(dir.responses, make.short.name("other_response", no_date = T),
sheet = "Sheet2", validate = T) # specify Sheet2 because the first one is a readme
or.edited$loop_index <- NA   #added this to overcome the problem of not finding loop_index column
if (nrow(or.request) != nrow(or.edited)) stop("Number of rows differs between or.request and or.edited!")
cleaning.log.other <- data.frame()
or.request <- load.requests(dir.requests,  make.short.name("other_requests", no_date = T), sheet = "Sheet2")
or.edited  <- load.requests(dir.responses, make.short.name("other_response", no_date = T),
sheet = "Sheet2", validate = T) # specify Sheet2 because the first one is a readme
or.edited$loop_index <- NA   #added this to overcome the problem of not finding loop_index column
if (nrow(or.request) != nrow(or.edited)) stop("Number of rows differs between or.request and or.edited!")
or.true.and.recode <- filter(or.edited, check == 1)
if (nrow(or.true.and.recode) > 0){
cat(paste0("Multiple columns selected in ", nrow(or.true.and.recode)," or.edited entries:\n",
paste0(or.true.and.recode %>% pull(uuid), collapse = "\n")), sep = "\n")
if(any(or.true.and.recode$ref.type != "select_multiple")) stop("One of those is not a select_multiple!!!")
# if(any(!is.na(or.true.and.recode$loop_index))) stop("Deal with loop code INSTEAD of UUID-LOOP-INDEX")
issue <- "Recoding other response"
for(r in 1:nrow(or.true.and.recode)){
x <- or.true.and.recode[r,]
# get list of choices from other response
if (str_detect(x$existing.v, ";")) {
choices <- str_trim(str_split(x$existing.v, ";")[[1]])
} else {
choices <- str_trim(str_split(x$existing.v, "\r\n")[[1]])
}
choices <- choices[choices!=""]
if(is.na(x$loop_index)){
old.value <- as.character(raw.main[raw.main$uuid==x$uuid[1], x$ref.name[1]])
} else {
old.value <- as.character(raw.loop1[raw.loop1$loop_index==x$loop_index[1], x$ref.name[1]])
}
l <- str_split(old.value, " ")[[1]]
# add to the cleaning log each choice in the other response
for (choice in choices){
# set corresponding variable to "1" if not already "1"
list.name <- get.choice.list.from.name(x$ref.name)
new.code <- filter(tool.choices, list_name==list.name & !!sym(label_colname)==choice)
if (nrow(new.code)!=1){
warning(paste0("Choice is not in the list. UUID: ", x$uuid,"; recode.into: ", choice))
return("err")
}
variable.name <- paste0(x$ref.name, "/", new.code$name)
if(is.na(x$loop_index)){
if (variable.name %in% colnames(raw.main)){
old.boolean <- raw.main[[variable.name]][raw.main$uuid==x$uuid[1]]
} else warning("Column not found")
} else {
if (variable.name %in% colnames(raw.loop1)){
old.boolean <- raw.loop1[[variable.name]][raw.loop1$loop_index==x$loop_index[1]]
} else warning("Column not found")
}
df <- data.frame(uuid=x$uuid, loop_index=x$loop_index, variable=variable.name, issue=issue,
old.value=old.boolean, new.value="1")
cleaning.log.other <<- rbind(cleaning.log.other, df)
l <- unique(c(l, new.code$name))
}
# update cumulative variable
new.value <- paste(sort(l), collapse=" ")
df <- data.frame(uuid=x$uuid, loop_index=x$loop_index, variable=x$ref.name, issue=issue,
old.value=old.value, new.value=new.value)
cleaning.log.other <<- rbind(cleaning.log.other, df)
}
or.edited <- or.edited %>% filter(check == 2)
}
or.true <- filter(or.edited, !is.na(true.v))
or.recode <- filter(or.edited, !is.na(existing.v))
or.remove <- filter(or.edited, !is.na(invalid.v))
#cleaning.log.other <- subset(cleaning.log.other, select = -loop_index)
# 1) handle invalid
print(paste("Number of responses to be deleted:", nrow(or.remove)))
if (nrow(or.remove)>0){
for (r in 1:nrow(or.remove)) {
if(is.na(or.remove$loop_index[r])){
add.to.cleaning.log.other.remove(raw.main, or.remove[r,])
#      recode.others(raw.main, or.remove[r,])
} else{
add.to.cleaning.log.other.remove(raw.loop1, or.remove[r,])
}
}
}
# 2) handle recoding
print(paste("Number of responses to be recoded:", nrow(or.recode)))
if (nrow(or.recode)>0){
for (r in 1:nrow(or.recode)) {
if(is.na(or.recode$loop_index[r])){
add.to.cleaning.log.other.recode(raw.main, or.recode[r,])
} else {
add.to.cleaning.log.other.recode(raw.loop1, or.recode[r,])
}
}
}
# 3) handle true\
or.true <- rbind(or.true, or.true.and.recode)
print(paste("Number of responses to be translated:", nrow(or.true)))
t <- or.true %>%
mutate(issue = "Translating other responses") %>%
rename(variable=name, old.value=response.uk, new.value=true.v) %>%
select(uuid, variable,issue, old.value, new.value)
####################### Customers ############################################
if (JMMI_variable == "Customers") {
cleaning.log.other <- rbind(cleaning.log.other, t)
raw.main <- raw.main %>%
apply.changes(cleaning.log.other)
}
##############################################################################
###################  Retailers ################################################
if (JMMI_variable == "Retailers") {
to_translate <- read_xlsx(make.filename.xlsx(paste0("output/", JMMI_variable, "/checking/responses"), "to_translate"))
cleaning.log.other <- rbind(cleaning.log.other, t, to_translate)
raw.main <- raw.main %>%
apply.changes(cleaning.log.other)
}
if (JMMI_variable == "Retailers") {
to_translate <- read_xlsx(paste0("output/", JMMI_variable, "/checking/responses/to_translate.xlsx"))
cleaning.log.other <- rbind(cleaning.log.other, t, to_translate)
raw.main <- raw.main %>%
apply.changes(cleaning.log.other)
}
cleaning.log <- bind_rows(cleaning.log, cleaning.log.other #, cleaning.log.other_loop2
)
################  Retailers ###################################################
if (JMMI_variable == "Retailers") {
prices <- c(
"b3_bread_price",
"c3_eggs_price",
"d3_milk_price",
"e3_potatoes_price",
"f3_carrots_price",
"g3_onions_price",
"h3_cabbage_price",
"i3_chicken_price",
"j3_oil_price",
"k3_flour_price",
"l3_rice_price",
"m3_buckwheat_price",
"n3_water_price",
"y3_cereal_porridge_price",
"o3_diapers_price",
"p3_body_soap_price",
"r3_laundry_soap_price",
"q3_powder_price",
"s3_toothpaste_price",
"t3_pads_price"
)
prices_final <- paste(prices,"_final_price",sep="")
cleaning.log.outliers <- data.frame()
# # define columns to check for outliers
#
cols.integer_main <- filter(tool.survey, type %in% c("decimal","integer"))
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
cols.integer_raw.main <- cols.integer_raw.main[!cols.integer_raw.main %in% prices]
cols.integer_raw.main <- c(cols.integer_raw.main,prices_final)
n.sd <- 3
res.outliers_main <- data.frame()
# # res.outliers_loop1 <- data.frame()
df.all <- data.frame()
# #------------------------------------------------------------------------------------------------------------
# # [MAIN SHEET] -> detect outliers
#
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
#
# # Outliers per country
for (col in cols.integer_raw.main) {
print(col)
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.log = (value > mean(value) + n.sd*sd(value)) |   ##change is.outlier.log to is.outlier.lin
(value < mean(value) - n.sd*sd(value)),
is.outlier.lin = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.lin) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Retailers_R15_outliers_requests.xlsx")
################################################################################
write.xlsx(raw.main, "output/Retailers/data_log/data.xlsx")
}
################### Customers #################################################
if (JMMI_variable == "Customers") {
# save.image(file = "Environment.RData")
# load("Environment.RData")
cleaning.log.outliers <- data.frame()
# define columns to check for outliers
cols.integer_main <- filter(tool.survey, type == "decimal")
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
# cols.integer_raw.loop1 <- cols.integer_main[cols.integer_main$name %in% colnames(raw.loop1),] %>% pull(name)
# cols <- filter(tool.survey, str_starts(name, "G_3")) %>% pull(name)
n.sd <- 2
res.outliers_main <- data.frame()
# res.outliers_loop1 <- data.frame()
df.all <- data.frame()
#------------------------------------------------------------------------------------------------------------
# [MAIN SHEET] -> detect outliers
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
# Outliers per country
for (col in cols.integer_raw.main) {
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.lin = (value > mean(value) + n.sd*sd(value)) |
(value < mean(value) - n.sd*sd(value)),
is.outlier.log = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.lin) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
#f.alpha <- function(x) return(ifelse(x, 1, 0))
#
## Outliers Boxplot generator per country
#
#df <- raw.main.outliers %>%
#  select(uuid, all_of(cols.integer_raw.main)) %>%
#  pivot_longer(-uuid, names_to = "variable", values_to = "value") %>%
#  mutate(value.log = log10(value)) %>%
#  left_join(select(res.outliers_main, -value) %>% mutate(is.outlier=T), by = c("uuid","variable")) %>%
#  mutate(is.outlier = ifelse(is.na(is.outlier), F, is.outlier)) %>%
#  filter(!is.na(value) & value>0)
#df <- gather(df, key = "measure", value = "value", variable)
#df.all <- rbind(df.all, df)
#
#
#write.xlsx(df.all, paste0("output/checking/outliers/main_outlier_prices_analysis_", n.sd, "sd.xlsx"), overwrite=T)
#
## generating prices boxplots for same locations
#g.outliers_main <- ggplot(df.all) +
#  geom_boxplot(aes(x= measure, y=value.log), width = 0.2) + ylab("Values (log10)") +
#  geom_point(aes(x=measure, y=value.log, group = measure), alpha=f.alpha(df.all$is.outlier), colour="red") +
#  facet_wrap(~value, ncol = 4, scales = "free_y")+
#  theme(axis.text.x = element_blank(),
#        axis.ticks.x = element_blank())
#
#
## Save
#ggsave(paste0("output/checking/outliers/main_outlier_prices_analysis_", n.sd, "sd.pdf"), g.outliers_main,
#       width = 40, height = 80, units = "cm", device="pdf")
#
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Customers_R15_outliers_lin_requests.xlsx")
write.xlsx(raw.main, "output/Customers/data_log/data.xlsx")
}
################  Retailers ###################################################
if (JMMI_variable == "Retailers") {
prices <- c(
"b3_bread_price",
"c3_eggs_price",
"d3_milk_price",
"e3_potatoes_price",
"f3_carrots_price",
"g3_onions_price",
"h3_cabbage_price",
"i3_chicken_price",
"j3_oil_price",
"k3_flour_price",
"l3_rice_price",
"m3_buckwheat_price",
"n3_water_price",
"y3_cereal_porridge_price",
"o3_diapers_price",
"p3_body_soap_price",
"r3_laundry_soap_price",
"q3_powder_price",
"s3_toothpaste_price",
"t3_pads_price"
)
prices_final <- paste(prices,"_final_price",sep="")
cleaning.log.outliers <- data.frame()
# # define columns to check for outliers
#
cols.integer_main <- filter(tool.survey, type %in% c("decimal","integer"))
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
cols.integer_raw.main <- cols.integer_raw.main[!cols.integer_raw.main %in% prices]
cols.integer_raw.main <- c(cols.integer_raw.main,prices_final)
n.sd <- 3
res.outliers_main <- data.frame()
# # res.outliers_loop1 <- data.frame()
df.all <- data.frame()
# #------------------------------------------------------------------------------------------------------------
# # [MAIN SHEET] -> detect outliers
#
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
#
# # Outliers per country
for (col in cols.integer_raw.main) {
print(col)
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.log = (value > mean(value) + n.sd*sd(value)) |   ##change is.outlier.log to is.outlier.lin
(value < mean(value) - n.sd*sd(value)),
is.outlier.lin = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.log) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Retailers_R15_outliers_log_requests.xlsx")
################################################################################
write.xlsx(raw.main, "output/Retailers/data_log/data.xlsx")
}
# RUN ONLY IF Anything need to be changed
outlier.recode <- load.requests(dir.responses, make.short.name("outliers_response", no_date = T))
outlier.check <- load.requests(dir.requests, make.short.name("outliers_requests", no_date = T))
if (nrow(outlier.check) != nrow(outlier.recode)) warning("Number of rows are not matching")
cleaning.log.outliers <- outlier.recode %>%
select(uuid, variable,issue,old.value,new.value) #%>%
#filter(is.na(new.value))
#cleaning.log.outliers <- subset(cleaning.log.outliers, select = -loop_index)
#Added the following line to convert to character, so the apply.changes can work properly
#raw.main[cols.integer_raw.main] <- sapply(raw.main[cols.integer_raw.main],as.character)
raw.main <- raw.main %>%
apply.changes(cleaning.log.outliers)
cleaning.log <- rbind(cleaning.log,cleaning.log.outliers)
####################### Retailers #############################################
if (JMMI_variable == "Retailers") {
raw.main <- raw.main %>%
mutate(b3_bread_price_final_price = b3_bread_price %_/_% b3_1_bread_size * 500,
c3_eggs_price_final_price = c3_eggs_price %_/_% c3_1_eggs_size * 10,
d3_milk_price_final_price = d3_milk_price %_/_% d3_1_milk_size * 0.9,
e3_potatoes_price_final_price = e3_potatoes_price %_/_% e3_1_potatoes_size * 1,
f3_carrots_price_final_price = f3_carrots_price %_/_% f3_1_carrots_size * 1,
g3_onions_price_final_price = g3_onions_price %_/_% g3_1_onions_size * 1,
h3_cabbage_price_final_price = h3_cabbage_price %_/_% h3_1_cabbage_size * 1,
i3_chicken_price_final_price = i3_chicken_price %_/_% i3_1_chicken_size * 1,
j3_oil_price_final_price = j3_oil_price %_/_% j3_1_oil_size * 0.9,
k3_flour_price_final_price = k3_flour_price %_/_% k3_1_flour_size * 1,
l3_rice_price_final_price = l3_rice_price %_/_% l3_1_rice_size * 1,
m3_buckwheat_price_final_price = m3_buckwheat_price %_/_% m3_1_buckwheat_size * 1,
n3_water_price_final_price = n3_water_price %_/_% n3_1_water_size * 1.5,
y3_cereal_porridge_price_final_price = y3_cereal_porridge_price %_/_% y3_1_cereal_porridge_size * 200,
o3_diapers_price_final_price = o3_diapers_price %_/_% o3_1_diapers_size * 50,
p3_body_soap_price_final_price = p3_body_soap_price %_/_% p3_1_body_soap_size * 75,
r3_laundry_soap_price_final_price = as.numeric(r3_laundry_soap_price) %_/_% r3_1_laundry_soap_size * 200,
q3_powder_price_final_price = q3_powder_price %_/_% q3_1_powder_size * 500,
s3_toothpaste_price_final_price = s3_toothpaste_price %_/_% s3_1_toothpaste_size * 75,
t3_pads_price_final_price = t3_pads_price %_/_% t3_1_pads_size * 10)
}
###############################################################################
#-------------------------------------------------------------------------------
# 6) Remove PII columns, apply any last changes, then save cleaned dataset
################################################################################
# finalize cleaning log:
cleaning.log <- cleaning.log %>% distinct() %>%
#filter(old.value %!=na% new.value) %>%
left_join(raw.main %>% select(uuid, any_of(enum_colname)))
if (length(list.files(make.filename.xlsx(paste0("output/", JMMI_variable, "/cleaning_log"), "cleaning_log", no_date = T))) > 0) {
cleaning.log.previous <- read_xlsx(make.filename.xlsx(paste0("output/", JMMI_variable, "/cleaning_log"), "cleaning_log"))
cleaning.log.whole <- rbind(cleaning.log.previous, cleaning.log)
} else cleaning.log.whole <- cleaning.log
# Output Cleaning Log
write.xlsx(cleaning.log, make.filename.xlsx(paste0("output/", JMMI_variable, "/cleaning_log"), "cleaning_log", no_date = T), overwrite = T)
# Output deletion Log
write.xlsx(deletion.log.new, make.filename.xlsx(paste0("output/", JMMI_variable, "/deletion_log"), "deletion_log", no_date = T), overwrite = T)
# combine new and previous data:
# ------------------------------------------------------------------------------
#if(!"main.data.previous" %in% ls()) {
#warning("main.data.previous was not found! Are you sure you don't have a previous data_log that you can load?")
#new.main <- raw.main
## new.loop1 <- raw.loop1
## new.loop2 <- raw.loop2
#}else{
## check if there are any columns somehow added during this cleaning process
#for(cc in colnames(raw.main)){
#if(!(cc %in% colnames(main.data.previous))){
#warning(paste("column",cc,"found in raw.main but not in main.data.previous!"))
#}}
## and the other way around:
#for(cc in colnames(main.data.previous)){
#if(!(cc %in% colnames(raw.main))){
#warning(paste("column",cc,"found in main.data.previous but not in raw.main!"))
#}}
#
#new.main  <- bind_rows(main.data.previous, raw.main) %>% filter(!uuid %in% deletion.log.whole$uuid)
## new.loop1 <- bind_rows(loop1.previous, raw.loop1) %>% filter(!uuid %in% deletion.log.whole$uuid)
## new.loop2 <- bind_rows(loop2.previous, raw.loop2) %>% filter(!uuid %in% deletion.log.whole$uuid)
#}
if (JMMI_variable == "Customers") {
## revive columns due to old version of questionary
cols_remove <- c(
"b7_vehicle_fuel/none_vehicles",
"b7_1_heating_fuel/none_heating"
)
## Add any changes to the tool?
raw.main <- raw.main %>%
select(-any_of(cols_remove, vars = NULL))
tool.survey <- tool.survey %>%
mutate(datasheet = "main")
pii.to.remove_main <- c(
"deviceid",
"audit",
"audit_URL",
"comments_enumerators")
new.main.removed  <- raw.main %>% select(-any_of(pii.to.remove_main))
}
##################### Retailers ##############################################
if (JMMI_variable == "Retailers") {
pii.to.remove_main <- c(
"a10_name_retailer",
"a11_branch_retailer",
"a12_phone_number",
"deviceid",
"audit",
"audit_URL",
"z4_like_name_retailer",
"z5_like_phone_number",
"z6_like_hromada",
"comments_enumerators"
)
new.main.removed  <- raw.main %>% select(-any_of(pii.to.remove_main))
}
##############################################################################
# All data write excel
datasheets <- list("main" = raw.main
)
write.xlsx(datasheets, make.filename.xlsx(paste0("output/", JMMI_variable, "/data_log"), "full_data"), overwrite = T,
zoom = 90, firstRow = T)
# final (pii removed)
datasheets_anon <- list("main" = new.main.removed
)
raw.main <- raw.main %>% select(-any_of(pii.to.remove_main))
write.xlsx(datasheets_anon, make.filename.xlsx(paste0("output/", JMMI_variable, "/final"), "final_clean_data"), overwrite = T,
zoom = 90, firstRow = T)
