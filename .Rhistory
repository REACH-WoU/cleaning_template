old.value=old.value, new.value=new.value)
cleaning.log.other <<- rbind(cleaning.log.other, df)
}
or.edited <- or.edited %>% filter(check == 2)
}
or.true <- filter(or.edited, !is.na(true.v))
or.recode <- filter(or.edited, !is.na(existing.v))
or.remove <- filter(or.edited, !is.na(invalid.v))
#cleaning.log.other <- subset(cleaning.log.other, select = -loop_index)
# 1) handle invalid
print(paste("Number of responses to be deleted:", nrow(or.remove)))
if (nrow(or.remove)>0){
for (r in 1:nrow(or.remove)) {
if(is.na(or.remove$loop_index[r])){
add.to.cleaning.log.other.remove(raw.main, or.remove[r,])
#      recode.others(raw.main, or.remove[r,])
} else{
add.to.cleaning.log.other.remove(raw.loop1, or.remove[r,])
}
}
}
# 2) handle recoding
print(paste("Number of responses to be recoded:", nrow(or.recode)))
if (nrow(or.recode)>0){
for (r in 1:nrow(or.recode)) {
if(is.na(or.recode$loop_index[r])){
add.to.cleaning.log.other.recode(raw.main, or.recode[r,])
} else {
add.to.cleaning.log.other.recode(raw.loop1, or.recode[r,])
}
}
}
# 3) handle true\
or.true <- rbind(or.true, or.true.and.recode)
print(paste("Number of responses to be translated:", nrow(or.true)))
t <- or.true %>%
mutate(issue = "Translating other responses") %>%
rename(variable=name, old.value=response.uk, new.value=true.v) %>%
select(uuid, variable,issue, old.value, new.value)
####################### Customers ############################################
#cleaning.log.other <- rbind(cleaning.log.other, t)
##############################################################################
###################  Retailers ################################################
cleaning.log.other <- rbind(cleaning.log.other, t, to_translate)
library(readxl)
to_translate <- read_excel("output/checking/responses/to_translate.xlsx")
View(to_translate)
View(cleaning.log)
View(cleaning.log.missing)
library(readxl)
to_translate <- read_excel("output/checking/responses/to_translate.xlsx")
View(to_translate)
View(to_translate)
cleaning.log.other <- data.frame()
or.request <- load.requests(dir.requests,  make.short.name("other_requests", no_date = T), sheet = "Sheet2")
or.edited  <- load.requests(dir.responses, make.short.name("other_response", no_date = T),
sheet = "Sheet2", validate = T) # specify Sheet2 because the first one is a readme
or.edited$loop_index <- NA   #added this to overcome the problem of not finding loop_index column
if (nrow(or.request) != nrow(or.edited)) stop("Number of rows differs between or.request and or.edited!")
or.true.and.recode <- filter(or.edited, check == 1)
if (nrow(or.true.and.recode) > 0){
cat(paste0("Multiple columns selected in ", nrow(or.true.and.recode)," or.edited entries:\n",
paste0(or.true.and.recode %>% pull(uuid), collapse = "\n")), sep = "\n")
if(any(or.true.and.recode$ref.type != "select_multiple")) stop("One of those is not a select_multiple!!!")
# if(any(!is.na(or.true.and.recode$loop_index))) stop("Deal with loop code INSTEAD of UUID-LOOP-INDEX")
issue <- "Recoding other response"
for(r in 1:nrow(or.true.and.recode)){
x <- or.true.and.recode[r,]
# get list of choices from other response
if (str_detect(x$existing.v, ";")) {
choices <- str_trim(str_split(x$existing.v, ";")[[1]])
} else {
choices <- str_trim(str_split(x$existing.v, "\r\n")[[1]])
}
choices <- choices[choices!=""]
if(is.na(x$loop_index)){
old.value <- as.character(raw.main[raw.main$uuid==x$uuid[1], x$ref.name[1]])
} else {
old.value <- as.character(raw.loop1[raw.loop1$loop_index==x$loop_index[1], x$ref.name[1]])
}
l <- str_split(old.value, " ")[[1]]
# add to the cleaning log each choice in the other response
for (choice in choices){
# set corresponding variable to "1" if not already "1"
list.name <- get.choice.list.from.name(x$ref.name)
new.code <- filter(tool.choices, list_name==list.name & !!sym(label_colname)==choice)
if (nrow(new.code)!=1){
warning(paste0("Choice is not in the list. UUID: ", x$uuid,"; recode.into: ", choice))
return("err")
}
variable.name <- paste0(x$ref.name, "/", new.code$name)
if(is.na(x$loop_index)){
if (variable.name %in% colnames(raw.main)){
old.boolean <- raw.main[[variable.name]][raw.main$uuid==x$uuid[1]]
} else warning("Column not found")
} else {
if (variable.name %in% colnames(raw.loop1)){
old.boolean <- raw.loop1[[variable.name]][raw.loop1$loop_index==x$loop_index[1]]
} else warning("Column not found")
}
df <- data.frame(uuid=x$uuid, loop_index=x$loop_index, variable=variable.name, issue=issue,
old.value=old.boolean, new.value="1")
cleaning.log.other <<- rbind(cleaning.log.other, df)
l <- unique(c(l, new.code$name))
}
# update cumulative variable
new.value <- paste(sort(l), collapse=" ")
df <- data.frame(uuid=x$uuid, loop_index=x$loop_index, variable=x$ref.name, issue=issue,
old.value=old.value, new.value=new.value)
cleaning.log.other <<- rbind(cleaning.log.other, df)
}
or.edited <- or.edited %>% filter(check == 2)
}
or.true <- filter(or.edited, !is.na(true.v))
or.recode <- filter(or.edited, !is.na(existing.v))
or.remove <- filter(or.edited, !is.na(invalid.v))
#cleaning.log.other <- subset(cleaning.log.other, select = -loop_index)
# 1) handle invalid
print(paste("Number of responses to be deleted:", nrow(or.remove)))
if (nrow(or.remove)>0){
for (r in 1:nrow(or.remove)) {
if(is.na(or.remove$loop_index[r])){
add.to.cleaning.log.other.remove(raw.main, or.remove[r,])
#      recode.others(raw.main, or.remove[r,])
} else{
add.to.cleaning.log.other.remove(raw.loop1, or.remove[r,])
}
}
}
# 2) handle recoding
print(paste("Number of responses to be recoded:", nrow(or.recode)))
if (nrow(or.recode)>0){
for (r in 1:nrow(or.recode)) {
if(is.na(or.recode$loop_index[r])){
add.to.cleaning.log.other.recode(raw.main, or.recode[r,])
} else {
add.to.cleaning.log.other.recode(raw.loop1, or.recode[r,])
}
}
}
# 3) handle true\
or.true <- rbind(or.true, or.true.and.recode)
print(paste("Number of responses to be translated:", nrow(or.true)))
t <- or.true %>%
mutate(issue = "Translating other responses") %>%
rename(variable=name, old.value=response.uk, new.value=true.v) %>%
select(uuid, variable,issue, old.value, new.value)
####################### Customers ############################################
#cleaning.log.other <- rbind(cleaning.log.other, t)
##############################################################################
###################  Retailers ################################################
cleaning.log.other <- rbind(cleaning.log.other, t, to_translate)
raw.main <- raw.main %>%
apply.changes(cleaning.log.other)
cleaning.log <- bind_rows(cleaning.log, cleaning.log.other #, cleaning.log.other_loop2
)
prices <- c(
"b3_bread_price",
"c3_eggs_price",
"d3_milk_price",
"e3_potatoes_price",
"f3_carrots_price",
"g3_onions_price",
"h3_cabbage_price",
"i3_chicken_price",
"j3_oil_price",
"k3_flour_price",
"l3_rice_price",
"m3_buckwheat_price",
"n3_water_price",
"y3_cereal_porridge_price",
"o3_diapers_price",
"p3_body_soap_price",
"r3_laundry_soap_price",
"q3_powder_price",
"s3_toothpaste_price",
"t3_pads_price"
)
prices_final <- paste(prices,"_final_price",sep="")
cleaning.log.outliers <- data.frame()
cols.integer_main <- filter(tool.survey, type %in% c("decimal","integer"))
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
cols.integer_raw.main <- cols.integer_raw.main[!cols.integer_raw.main %in% prices]
cols.integer_raw.main <- c(cols.integer_raw.main,prices_final)
n.sd <- 3
res.outliers_main <- data.frame()
df.all <- data.frame()
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
for (col in cols.integer_raw.main) {
print(col)
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.log = (value > mean(value) + n.sd*sd(value)) |   ##change is.outlier.log to is.outlier.lin
(value < mean(value) - n.sd*sd(value)),
is.outlier.lin = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.log) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Retailers_R15_outliers_requests")
cleaning.log.outliers <- data.frame()
# # define columns to check for outliers
#
cols.integer_main <- filter(tool.survey, type %in% c("decimal","integer"))
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
cols.integer_raw.main <- cols.integer_raw.main[!cols.integer_raw.main %in% prices]
cols.integer_raw.main <- c(cols.integer_raw.main,prices_final)
n.sd <- 3
res.outliers_main <- data.frame()
# # res.outliers_loop1 <- data.frame()
df.all <- data.frame()
# #------------------------------------------------------------------------------------------------------------
# # [MAIN SHEET] -> detect outliers
#
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
#
# # Outliers per country
for (col in cols.integer_raw.main) {
print(col)
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.log = (value > mean(value) + n.sd*sd(value)) |   ##change is.outlier.log to is.outlier.lin
(value < mean(value) - n.sd*sd(value)),
is.outlier.lin = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.lin) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Retailers_R15_outliers_lin_requests")
write.xlsx(raw.main, "data_log/data.xlsx")
write.xlsx(raw.main, "output/data_log/data.xlsx")
cleaning.log.outliers <- data.frame()
# # define columns to check for outliers
#
cols.integer_main <- filter(tool.survey, type %in% c("decimal","integer"))
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
cols.integer_raw.main <- cols.integer_raw.main[!cols.integer_raw.main %in% prices]
cols.integer_raw.main <- c(cols.integer_raw.main,prices_final)
n.sd <- 3
res.outliers_main <- data.frame()
# # res.outliers_loop1 <- data.frame()
df.all <- data.frame()
# #------------------------------------------------------------------------------------------------------------
# # [MAIN SHEET] -> detect outliers
#
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
#
# # Outliers per country
for (col in cols.integer_raw.main) {
print(col)
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.log = (value > mean(value) + n.sd*sd(value)) |   ##change is.outlier.log to is.outlier.lin
(value < mean(value) - n.sd*sd(value)),
is.outlier.lin = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.lin) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Retailers_R15_outliers_lin_requests.xlsx")
cleaning.log.outliers <- data.frame()
# # define columns to check for outliers
#
cols.integer_main <- filter(tool.survey, type %in% c("decimal","integer"))
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
cols.integer_raw.main <- cols.integer_raw.main[!cols.integer_raw.main %in% prices]
cols.integer_raw.main <- c(cols.integer_raw.main,prices_final)
n.sd <- 3
res.outliers_main <- data.frame()
# # res.outliers_loop1 <- data.frame()
df.all <- data.frame()
# #------------------------------------------------------------------------------------------------------------
# # [MAIN SHEET] -> detect outliers
#
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
#
# # Outliers per country
for (col in cols.integer_raw.main) {
print(col)
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.log = (value > mean(value) + n.sd*sd(value)) |   ##change is.outlier.log to is.outlier.lin
(value < mean(value) - n.sd*sd(value)),
is.outlier.lin = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.log) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Retailers_R15_outliers_lin_requests.xlsx")
################################################################################
write.xlsx(raw.main, "output/data_log/data.xlsx")
################### Customers #################################################
# save.image(file = "Environment.RData")
# load("Environment.RData")
cleaning.log.outliers <- data.frame()
# define columns to check for outliers
cols.integer_main <- filter(tool.survey, type == "decimal")
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
# cols.integer_raw.loop1 <- cols.integer_main[cols.integer_main$name %in% colnames(raw.loop1),] %>% pull(name)
# cols <- filter(tool.survey, str_starts(name, "G_3")) %>% pull(name)
n.sd <- 2
res.outliers_main <- data.frame()
# res.outliers_loop1 <- data.frame()
df.all <- data.frame()
#------------------------------------------------------------------------------------------------------------
# [MAIN SHEET] -> detect outliers
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
# Outliers per country
for (col in cols.integer_raw.main) {
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.lin = (value > mean(value) + n.sd*sd(value)) |
(value < mean(value) - n.sd*sd(value)),
is.outlier.log = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.log) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
#f.alpha <- function(x) return(ifelse(x, 1, 0))
#
## Outliers Boxplot generator per country
#
#df <- raw.main.outliers %>%
#  select(uuid, all_of(cols.integer_raw.main)) %>%
#  pivot_longer(-uuid, names_to = "variable", values_to = "value") %>%
#  mutate(value.log = log10(value)) %>%
#  left_join(select(res.outliers_main, -value) %>% mutate(is.outlier=T), by = c("uuid","variable")) %>%
#  mutate(is.outlier = ifelse(is.na(is.outlier), F, is.outlier)) %>%
#  filter(!is.na(value) & value>0)
#df <- gather(df, key = "measure", value = "value", variable)
#df.all <- rbind(df.all, df)
#
#
#write.xlsx(df.all, paste0("output/checking/outliers/main_outlier_prices_analysis_", n.sd, "sd.xlsx"), overwrite=T)
#
## generating prices boxplots for same locations
#g.outliers_main <- ggplot(df.all) +
#  geom_boxplot(aes(x= measure, y=value.log), width = 0.2) + ylab("Values (log10)") +
#  geom_point(aes(x=measure, y=value.log, group = measure), alpha=f.alpha(df.all$is.outlier), colour="red") +
#  facet_wrap(~value, ncol = 4, scales = "free_y")+
#  theme(axis.text.x = element_blank(),
#        axis.ticks.x = element_blank())
#
#
## Save
#ggsave(paste0("output/checking/outliers/main_outlier_prices_analysis_", n.sd, "sd.pdf"), g.outliers_main,
#       width = 40, height = 80, units = "cm", device="pdf")
#
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Customers_R15_outliers_requests.xlsx")
cleaning.log.outliers <- data.frame()
# # define columns to check for outliers
#
cols.integer_main <- filter(tool.survey, type %in% c("decimal","integer"))
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
cols.integer_raw.main <- cols.integer_raw.main[!cols.integer_raw.main %in% prices]
cols.integer_raw.main <- c(cols.integer_raw.main,prices_final)
n.sd <- 3
res.outliers_main <- data.frame()
# # res.outliers_loop1 <- data.frame()
df.all <- data.frame()
# #------------------------------------------------------------------------------------------------------------
# # [MAIN SHEET] -> detect outliers
#
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
#
# # Outliers per country
for (col in cols.integer_raw.main) {
print(col)
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.log = (value > mean(value) + n.sd*sd(value)) |   ##change is.outlier.log to is.outlier.lin
(value < mean(value) - n.sd*sd(value)),
is.outlier.lin = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.log) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Retailers_R15_outliers_lin_requests.xlsx")
cleaning.log.outliers <- data.frame()
# # define columns to check for outliers
#
cols.integer_main <- filter(tool.survey, type %in% c("decimal","integer"))
cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
cols.integer_raw.main <- cols.integer_raw.main[!cols.integer_raw.main %in% prices]
cols.integer_raw.main <- c(cols.integer_raw.main,prices_final)
n.sd <- 3
res.outliers_main <- data.frame()
# # res.outliers_loop1 <- data.frame()
df.all <- data.frame()
# #------------------------------------------------------------------------------------------------------------
# # [MAIN SHEET] -> detect outliers
#
raw.main.outliers <- raw.main %>%
select("uuid", cols.integer_raw.main) %>%
mutate_at(cols.integer_raw.main, as.numeric)
#
# # Outliers per country
for (col in cols.integer_raw.main) {
print(col)
values <- raw.main.outliers %>%
filter(!!sym(col) %_>_% 0) %>%
rename(value=col) %>%  select(uuid, value) %>%
mutate(value.log=log10(value)) %>%  mutate(variable=col) %>%
mutate(is.outlier.log = (value > mean(value) + n.sd*sd(value)) |   ##change is.outlier.log to is.outlier.lin
(value < mean(value) - n.sd*sd(value)),
is.outlier.lin = (value.log > mean(value.log) + n.sd*sd(value.log)) |
(value.log < mean(value.log) - n.sd*sd(value.log)))
values <- filter(values, is.outlier.lin) %>%  select(uuid, variable, value)
if (nrow(values)>0) print(paste0(col, ": ", nrow(values), " outliers detected"))
res.outliers_main <- rbind(res.outliers_main, values)
}
# Output requests to check
res.outliers_main <- res.outliers_main %>%
mutate(issue = "Outliers",
loop_index = NA,
new.value = NA,
explanation=NA) %>%
rename("old.value"=value) %>%
select(uuid,loop_index,variable,issue,old.value,new.value,explanation)
cleaning.log.outliers <- rbind(cleaning.log.outliers,res.outliers_main)
cleaning.log.outliers$check.id <- 1
save.follow.up.requests(cleaning.log.outliers,"JMMI_Retailers_R15_outliers_requests.xlsx")
